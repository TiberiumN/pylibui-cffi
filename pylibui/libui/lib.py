import platform

from cffi import FFI
import os

# DO NOT EDIT THIS FILE
# AUTO-GENERATED BY bindings.py
ffi = FFI()
ffi.cdef('''
// This constant is provided because M_PI is nonstandard.
// This comes from Go's math.Pi, which in turn comes from http://oeis.org/A000796.

// TODO uiBool?

typedef struct uiInitOptions uiInitOptions;

struct uiInitOptions {
	size_t Size;
};

 const char *uiInit(uiInitOptions *options);
 void uiUninit(void);
 void uiFreeInitError(const char *err);

 void uiMain(void);
 void uiMainSteps(void);
 int uiMainStep(int wait);
 void uiQuit(void);

 void uiQueueMain(void (*f)(void *data), void *data);

 void uiOnShouldQuit(int (*f)(void *data), void *data);

 void uiFreeText(char *text);

typedef struct uiControl uiControl;

struct uiControl {
	uint32_t Signature;
	uint32_t OSSignature;
	uint32_t TypeSignature;
	void (*Destroy)(uiControl *);
	uintptr_t (*Handle)(uiControl *);
	uiControl *(*Parent)(uiControl *);
	void (*SetParent)(uiControl *, uiControl *);
	int (*Toplevel)(uiControl *);
	int (*Visible)(uiControl *);
	void (*Show)(uiControl *);
	void (*Hide)(uiControl *);
	int (*Enabled)(uiControl *);
	void (*Enable)(uiControl *);
	void (*Disable)(uiControl *);
};
// TOOD add argument names to all arguments

// TEST DOTDOTDOT
#define uiControl ...
 void uiControlDestroy(uiControl *);
 uintptr_t uiControlHandle(uiControl *);
 uiControl *uiControlParent(uiControl *);
 void uiControlSetParent(uiControl *, uiControl *);
 int uiControlToplevel(uiControl *);
 int uiControlVisible(uiControl *);
 void uiControlShow(uiControl *);
 void uiControlHide(uiControl *);
 int uiControlEnabled(uiControl *);
 void uiControlEnable(uiControl *);
 void uiControlDisable(uiControl *);

 uiControl *uiAllocControl(size_t n, uint32_t OSsig, uint32_t typesig, const char *typenamestr);
 void uiFreeControl(uiControl *);

// TODO make sure all controls have these
 void uiControlVerifySetParent(uiControl *, uiControl *);
 int uiControlEnabledToUser(uiControl *);

 void uiUserBugCannotSetParentOnToplevel(const char *type);

typedef struct uiWindow uiWindow;

// TEST DOTDOTDOT
#define uiWindow ...
 char *uiWindowTitle(uiWindow *w);
 void uiWindowSetTitle(uiWindow *w, const char *title);
 void uiWindowContentSize(uiWindow *w, int *width, int *height);
 void uiWindowSetContentSize(uiWindow *w, int width, int height);
 int uiWindowFullscreen(uiWindow *w);
 void uiWindowSetFullscreen(uiWindow *w, int fullscreen);
 void uiWindowOnContentSizeChanged(uiWindow *w, void (*f)(uiWindow *, void *), void *data);
 void uiWindowOnClosing(uiWindow *w, int (*f)(uiWindow *w, void *data), void *data);
 int uiWindowBorderless(uiWindow *w);
 void uiWindowSetBorderless(uiWindow *w, int borderless);
 void uiWindowSetChild(uiWindow *w, uiControl *child);
 int uiWindowMargined(uiWindow *w);
 void uiWindowSetMargined(uiWindow *w, int margined);
 uiWindow *uiNewWindow(const char *title, int width, int height, int hasMenubar);

typedef struct uiButton uiButton;
// TEST DOTDOTDOT
#define uiButton ...
 char *uiButtonText(uiButton *b);
 void uiButtonSetText(uiButton *b, const char *text);
 void uiButtonOnClicked(uiButton *b, void (*f)(uiButton *b, void *data), void *data);
 uiButton *uiNewButton(const char *text);

// TEST DOTDOTDOT
typedef struct uiBox uiBox;
#define uiBox ...
 void uiBoxAppend(uiBox *b, uiControl *child, int stretchy);
 void uiBoxDelete(uiBox *b, int index);
 int uiBoxPadded(uiBox *b);
 void uiBoxSetPadded(uiBox *b, int padded);
 uiBox *uiNewHorizontalBox(void);
 uiBox *uiNewVerticalBox(void);

typedef struct uiCheckbox uiCheckbox;
// TEST DOTDOTDOT
#define uiCheckbox ...
 char *uiCheckboxText(uiCheckbox *c);
 void uiCheckboxSetText(uiCheckbox *c, const char *text);
 void uiCheckboxOnToggled(uiCheckbox *c, void (*f)(uiCheckbox *c, void *data), void *data);
 int uiCheckboxChecked(uiCheckbox *c);
 void uiCheckboxSetChecked(uiCheckbox *c, int checked);
 uiCheckbox *uiNewCheckbox(const char *text);

typedef struct uiEntry uiEntry;
// TEST DOTDOTDOT
#define uiEntry ...
 char *uiEntryText(uiEntry *e);
 void uiEntrySetText(uiEntry *e, const char *text);
 void uiEntryOnChanged(uiEntry *e, void (*f)(uiEntry *e, void *data), void *data);
 int uiEntryReadOnly(uiEntry *e);
 void uiEntrySetReadOnly(uiEntry *e, int readonly);
 uiEntry *uiNewEntry(void);
 uiEntry *uiNewPasswordEntry(void);
 uiEntry *uiNewSearchEntry(void);

typedef struct uiLabel uiLabel;
// TEST DOTDOTDOT
#define uiLabel ...
 char *uiLabelText(uiLabel *l);
 void uiLabelSetText(uiLabel *l, const char *text);
 uiLabel *uiNewLabel(const char *text);

typedef struct uiTab uiTab;
// TEST DOTDOTDOT
#define uiTab ...
 void uiTabAppend(uiTab *t, const char *name, uiControl *c);
 void uiTabInsertAt(uiTab *t, const char *name, int before, uiControl *c);
 void uiTabDelete(uiTab *t, int index);
 int uiTabNumPages(uiTab *t);
 int uiTabMargined(uiTab *t, int page);
 void uiTabSetMargined(uiTab *t, int page, int margined);
 uiTab *uiNewTab(void);

typedef struct uiGroup uiGroup;
// TEST DOTDOTDOT
#define uiGroup ...
 char *uiGroupTitle(uiGroup *g);
 void uiGroupSetTitle(uiGroup *g, const char *title);
 void uiGroupSetChild(uiGroup *g, uiControl *c);
 int uiGroupMargined(uiGroup *g);
 void uiGroupSetMargined(uiGroup *g, int margined);
 uiGroup *uiNewGroup(const char *title);

// spinbox/slider rules:
// setting value outside of range will automatically clamp
// initial value is minimum
// complaint if min >= max?

typedef struct uiSpinbox uiSpinbox;
// TEST DOTDOTDOT
#define uiSpinbox ...
 int uiSpinboxValue(uiSpinbox *s);
 void uiSpinboxSetValue(uiSpinbox *s, int value);
 void uiSpinboxOnChanged(uiSpinbox *s, void (*f)(uiSpinbox *s, void *data), void *data);
 uiSpinbox *uiNewSpinbox(int min, int max);

typedef struct uiSlider uiSlider;
// TEST DOTDOTDOT
#define uiSlider ...
 int uiSliderValue(uiSlider *s);
 void uiSliderSetValue(uiSlider *s, int value);
 void uiSliderOnChanged(uiSlider *s, void (*f)(uiSlider *s, void *data), void *data);
 uiSlider *uiNewSlider(int min, int max);

typedef struct uiProgressBar uiProgressBar;
// TEST DOTDOTDOT
#define uiProgressBar ...
 int uiProgressBarValue(uiProgressBar *p);
 void uiProgressBarSetValue(uiProgressBar *p, int n);
 uiProgressBar *uiNewProgressBar(void);

typedef struct uiSeparator uiSeparator;
// TEST DOTDOTDOT
#define uiSeparator ...
 uiSeparator *uiNewHorizontalSeparator(void);
 uiSeparator *uiNewVerticalSeparator(void);

typedef struct uiCombobox uiCombobox;
// TEST DOTDOTDOT
#define uiCombobox ...
 void uiComboboxAppend(uiCombobox *c, const char *text);
 int uiComboboxSelected(uiCombobox *c);
 void uiComboboxSetSelected(uiCombobox *c, int n);
 void uiComboboxOnSelected(uiCombobox *c, void (*f)(uiCombobox *c, void *data), void *data);
 uiCombobox *uiNewCombobox(void);

typedef struct uiEditableCombobox uiEditableCombobox;
// TEST DOTDOTDOT
#define uiEditableCombobox ...
 void uiEditableComboboxAppend(uiEditableCombobox *c, const char *text);
 char *uiEditableComboboxText(uiEditableCombobox *c);
 void uiEditableComboboxSetText(uiEditableCombobox *c, const char *text);
// TODO what do we call a function that sets the currently selected item and fills the text field with it? editable comboboxes have no consistent concept of selected item
 void uiEditableComboboxOnChanged(uiEditableCombobox *c, void (*f)(uiEditableCombobox *c, void *data), void *data);
 uiEditableCombobox *uiNewEditableCombobox(void);

typedef struct uiRadioButtons uiRadioButtons;
// TEST DOTDOTDOT
#define uiRadioButtons ...
 void uiRadioButtonsAppend(uiRadioButtons *r, const char *text);
 int uiRadioButtonsSelected(uiRadioButtons *r);
 void uiRadioButtonsSetSelected(uiRadioButtons *r, int n);
 void uiRadioButtonsOnSelected(uiRadioButtons *r, void (*f)(uiRadioButtons *, void *), void *data);
 uiRadioButtons *uiNewRadioButtons(void);

typedef struct uiDateTimePicker uiDateTimePicker;
// TEST DOTDOTDOT
#define uiDateTimePicker ...
 uiDateTimePicker *uiNewDateTimePicker(void);
 uiDateTimePicker *uiNewDatePicker(void);
 uiDateTimePicker *uiNewTimePicker(void);

// TODO provide a facility for entering tab stops?
typedef struct uiMultilineEntry uiMultilineEntry;
// TEST DOTDOTDOT
#define uiMultilineEntry ...
 char *uiMultilineEntryText(uiMultilineEntry *e);
 void uiMultilineEntrySetText(uiMultilineEntry *e, const char *text);
 void uiMultilineEntryAppend(uiMultilineEntry *e, const char *text);
 void uiMultilineEntryOnChanged(uiMultilineEntry *e, void (*f)(uiMultilineEntry *e, void *data), void *data);
 int uiMultilineEntryReadOnly(uiMultilineEntry *e);
 void uiMultilineEntrySetReadOnly(uiMultilineEntry *e, int readonly);
 uiMultilineEntry *uiNewMultilineEntry(void);
 uiMultilineEntry *uiNewNonWrappingMultilineEntry(void);

typedef struct uiMenuItem uiMenuItem;
// TEST DOTDOTDOT
#define uiMenuItem ...
 void uiMenuItemEnable(uiMenuItem *m);
 void uiMenuItemDisable(uiMenuItem *m);
 void uiMenuItemOnClicked(uiMenuItem *m, void (*f)(uiMenuItem *sender, uiWindow *window, void *data), void *data);
 int uiMenuItemChecked(uiMenuItem *m);
 void uiMenuItemSetChecked(uiMenuItem *m, int checked);

typedef struct uiMenu uiMenu;
// TEST DOTDOTDOT
#define uiMenu ...
 uiMenuItem *uiMenuAppendItem(uiMenu *m, const char *name);
 uiMenuItem *uiMenuAppendCheckItem(uiMenu *m, const char *name);
 uiMenuItem *uiMenuAppendQuitItem(uiMenu *m);
 uiMenuItem *uiMenuAppendPreferencesItem(uiMenu *m);
 uiMenuItem *uiMenuAppendAboutItem(uiMenu *m);
 void uiMenuAppendSeparator(uiMenu *m);
 uiMenu *uiNewMenu(const char *name);

 char *uiOpenFile(uiWindow *parent);
 char *uiSaveFile(uiWindow *parent);
 void uiMsgBox(uiWindow *parent, const char *title, const char *description);
 void uiMsgBoxError(uiWindow *parent, const char *title, const char *description);

typedef struct uiArea uiArea;
typedef struct uiAreaHandler uiAreaHandler;
typedef struct uiAreaDrawParams uiAreaDrawParams;
typedef struct uiAreaMouseEvent uiAreaMouseEvent;
typedef struct uiAreaKeyEvent uiAreaKeyEvent;

typedef struct uiDrawContext uiDrawContext;

struct uiAreaHandler {
	void (*Draw)(uiAreaHandler *, uiArea *, uiAreaDrawParams *);
	// TODO document that resizes cause a full redraw for non-scrolling areas; implementation-defined for scrolling areas
	void (*MouseEvent)(uiAreaHandler *, uiArea *, uiAreaMouseEvent *);
	// TODO document that on first show if the mouse is already in the uiArea then one gets sent with left=0
	// TODO what about when the area is hidden and then shown again?
	void (*MouseCrossed)(uiAreaHandler *, uiArea *, int left);
	void (*DragBroken)(uiAreaHandler *, uiArea *);
	int (*KeyEvent)(uiAreaHandler *, uiArea *, uiAreaKeyEvent *);
};

// TODO RTL layouts?
// TODO reconcile edge and corner naming
typedef unsigned int uiWindowResizeEdge; enum{
	uiWindowResizeEdgeLeft,
	uiWindowResizeEdgeTop,
	uiWindowResizeEdgeRight,
	uiWindowResizeEdgeBottom,
	uiWindowResizeEdgeTopLeft,
	uiWindowResizeEdgeTopRight,
	uiWindowResizeEdgeBottomLeft,
	uiWindowResizeEdgeBottomRight,
	// TODO have one for keyboard resizes?
	// TODO GDK doesn't seem to have any others, including for keyboards...
	// TODO way to bring up the system menu instead?
};
// TEST DOTDOTDOT
#define uiArea ...
// TODO give a better name
// TODO document the types of width and height
 void uiAreaSetSize(uiArea *a, int width, int height);
// TODO uiAreaQueueRedraw()
 void uiAreaQueueRedrawAll(uiArea *a);
 void uiAreaScrollTo(uiArea *a, double x, double y, double width, double height);
// TODO document these can only be called within Mouse() handlers
// TODO should these be allowed on scrolling areas?
// TODO decide which mouse events should be accepted; Down is the only one guaranteed to work right now
// TODO what happens to events after calling this up to and including the next mouse up?
// TODO release capture?
 void uiAreaBeginUserWindowMove(uiArea *a);
 void uiAreaBeginUserWindowResize(uiArea *a, uiWindowResizeEdge edge);
 uiArea *uiNewArea(uiAreaHandler *ah);
 uiArea *uiNewScrollingArea(uiAreaHandler *ah, int width, int height);

struct uiAreaDrawParams {
	uiDrawContext *Context;

	// TODO document that this is only defined for nonscrolling areas
	double AreaWidth;
	double AreaHeight;

	double ClipX;
	double ClipY;
	double ClipWidth;
	double ClipHeight;
};

typedef struct uiDrawPath uiDrawPath;
typedef struct uiDrawBrush uiDrawBrush;
typedef struct uiDrawStrokeParams uiDrawStrokeParams;
typedef struct uiDrawMatrix uiDrawMatrix;

typedef struct uiDrawBrushGradientStop uiDrawBrushGradientStop;




typedef unsigned int uiDrawBrushType; enum {
	uiDrawBrushTypeSolid,
	uiDrawBrushTypeLinearGradient,
	uiDrawBrushTypeRadialGradient,
	uiDrawBrushTypeImage,
};

typedef unsigned int uiDrawLineCap; enum {
	uiDrawLineCapFlat,
	uiDrawLineCapRound,
	uiDrawLineCapSquare,
};

typedef unsigned int uiDrawLineJoin; enum {
	uiDrawLineJoinMiter,
	uiDrawLineJoinRound,
	uiDrawLineJoinBevel,
};

// this is the default for botoh cairo and Direct2D (in the latter case, from the C++ helper functions)
// Core Graphics doesn't explicitly specify a default, but NSBezierPath allows you to choose one, and this is the initial value
// so we're good to use it too!

typedef unsigned int uiDrawFillMode; enum {
	uiDrawFillModeWinding,
	uiDrawFillModeAlternate,
};

struct uiDrawMatrix {
	double M11;
	double M12;
	double M21;
	double M22;
	double M31;
	double M32;
};

struct uiDrawBrush {
	uiDrawBrushType Type;

	// solid brushes
	double R;
	double G;
	double B;
	double A;

	// gradient brushes
	double X0;		// linear: start X, radial: start X
	double Y0;		// linear: start Y, radial: start Y
	double X1;		// linear: end X, radial: outer circle center X
	double Y1;		// linear: end Y, radial: outer circle center Y
	double OuterRadius;		// radial gradients only
	uiDrawBrushGradientStop *Stops;
	size_t NumStops;
	// TODO extend mode
	// cairo: none, repeat, reflect, pad; no individual control
	// Direct2D: repeat, reflect, pad; no individual control
	// Core Graphics: none, pad; before and after individually
	// TODO cairo documentation is inconsistent about pad

	// TODO images

	// TODO transforms
};

struct uiDrawBrushGradientStop {
	double Pos;
	double R;
	double G;
	double B;
	double A;
};

struct uiDrawStrokeParams {
	uiDrawLineCap Cap;
	uiDrawLineJoin Join;
	// TODO what if this is 0? on windows there will be a crash with dashing
	double Thickness;
	double MiterLimit;
	double *Dashes;
	// TOOD what if this is 1 on Direct2D?
	// TODO what if a dash is 0 on Cairo or Quartz?
	size_t NumDashes;
	double DashPhase;
};

 uiDrawPath *uiDrawNewPath(uiDrawFillMode fillMode);
 void uiDrawFreePath(uiDrawPath *p);

 void uiDrawPathNewFigure(uiDrawPath *p, double x, double y);
 void uiDrawPathNewFigureWithArc(uiDrawPath *p, double xCenter, double yCenter, double radius, double startAngle, double sweep, int negative);
 void uiDrawPathLineTo(uiDrawPath *p, double x, double y);
// notes: angles are both relative to 0 and go counterclockwise
// TODO is the initial line segment on cairo and OS X a proper join?
// TODO what if sweep < 0?
 void uiDrawPathArcTo(uiDrawPath *p, double xCenter, double yCenter, double radius, double startAngle, double sweep, int negative);
 void uiDrawPathBezierTo(uiDrawPath *p, double c1x, double c1y, double c2x, double c2y, double endX, double endY);
// TODO quadratic bezier
 void uiDrawPathCloseFigure(uiDrawPath *p);

// TODO effect of these when a figure is already started
 void uiDrawPathAddRectangle(uiDrawPath *p, double x, double y, double width, double height);

 void uiDrawPathEnd(uiDrawPath *p);

 void uiDrawStroke(uiDrawContext *c, uiDrawPath *path, uiDrawBrush *b, uiDrawStrokeParams *p);
 void uiDrawFill(uiDrawContext *c, uiDrawPath *path, uiDrawBrush *b);

// TODO primitives:
// - rounded rectangles
// - elliptical arcs
// - quadratic bezier curves

 void uiDrawMatrixSetIdentity(uiDrawMatrix *m);
 void uiDrawMatrixTranslate(uiDrawMatrix *m, double x, double y);
 void uiDrawMatrixScale(uiDrawMatrix *m, double xCenter, double yCenter, double x, double y);
 void uiDrawMatrixRotate(uiDrawMatrix *m, double x, double y, double amount);
 void uiDrawMatrixSkew(uiDrawMatrix *m, double x, double y, double xamount, double yamount);
 void uiDrawMatrixMultiply(uiDrawMatrix *dest, uiDrawMatrix *src);
 int uiDrawMatrixInvertible(uiDrawMatrix *m);
 int uiDrawMatrixInvert(uiDrawMatrix *m);
 void uiDrawMatrixTransformPoint(uiDrawMatrix *m, double *x, double *y);
 void uiDrawMatrixTransformSize(uiDrawMatrix *m, double *x, double *y);

 void uiDrawTransform(uiDrawContext *c, uiDrawMatrix *m);

// TODO add a uiDrawPathStrokeToFill() or something like that
 void uiDrawClip(uiDrawContext *c, uiDrawPath *path);

 void uiDrawSave(uiDrawContext *c);
 void uiDrawRestore(uiDrawContext *c);

// TODO manage the use of Text, Font, and TextFont, and of the uiDrawText prefix in general

///// TODO reconsider this
typedef struct uiDrawFontFamilies uiDrawFontFamilies;

 uiDrawFontFamilies *uiDrawListFontFamilies(void);
 int uiDrawFontFamiliesNumFamilies(uiDrawFontFamilies *ff);
 char *uiDrawFontFamiliesFamily(uiDrawFontFamilies *ff, int n);
 void uiDrawFreeFontFamilies(uiDrawFontFamilies *ff);
///// END TODO

typedef struct uiDrawTextLayout uiDrawTextLayout;
typedef struct uiDrawTextFont uiDrawTextFont;
typedef struct uiDrawTextFontDescriptor uiDrawTextFontDescriptor;
typedef struct uiDrawTextFontMetrics uiDrawTextFontMetrics;





typedef unsigned int uiDrawTextWeight; enum {
	uiDrawTextWeightThin,
	uiDrawTextWeightUltraLight,
	uiDrawTextWeightLight,
	uiDrawTextWeightBook,
	uiDrawTextWeightNormal,
	uiDrawTextWeightMedium,
	uiDrawTextWeightSemiBold,
	uiDrawTextWeightBold,
	uiDrawTextWeightUltraBold,
	uiDrawTextWeightHeavy,
	uiDrawTextWeightUltraHeavy,
};

typedef unsigned int uiDrawTextItalic; enum {
	uiDrawTextItalicNormal,
	uiDrawTextItalicOblique,
	uiDrawTextItalicItalic,
};


typedef unsigned int uiDrawTextStretch; enum {
	uiDrawTextStretchUltraCondensed,
	uiDrawTextStretchExtraCondensed,
	uiDrawTextStretchCondensed,
	uiDrawTextStretchSemiCondensed,
	uiDrawTextStretchNormal,
	uiDrawTextStretchSemiExpanded,
	uiDrawTextStretchExpanded,
	uiDrawTextStretchExtraExpanded,
	uiDrawTextStretchUltraExpanded,
};

struct uiDrawTextFontDescriptor {
	const char *Family;
	double Size;
	uiDrawTextWeight Weight;
	uiDrawTextItalic Italic;
	uiDrawTextStretch Stretch;
};

struct uiDrawTextFontMetrics {
	double Ascent;
	double Descent;
	double Leading;
	// TODO do these two mean the same across all platforms?
	double UnderlinePos;
	double UnderlineThickness;
};

 uiDrawTextFont *uiDrawLoadClosestFont(const uiDrawTextFontDescriptor *desc);
 void uiDrawFreeTextFont(uiDrawTextFont *font);
 uintptr_t uiDrawTextFontHandle(uiDrawTextFont *font);
 void uiDrawTextFontDescribe(uiDrawTextFont *font, uiDrawTextFontDescriptor *desc);
// TODO make copy with given attributes methods?
// TODO yuck this name
 void uiDrawTextFontGetMetrics(uiDrawTextFont *font, uiDrawTextFontMetrics *metrics);

// TODO initial line spacing? and what about leading?
 uiDrawTextLayout *uiDrawNewTextLayout(const char *text, uiDrawTextFont *defaultFont, double width);
 void uiDrawFreeTextLayout(uiDrawTextLayout *layout);
// TODO get width
 void uiDrawTextLayoutSetWidth(uiDrawTextLayout *layout, double width);
 void uiDrawTextLayoutExtents(uiDrawTextLayout *layout, double *width, double *height);

// and the attributes that you can set on a text layout
 void uiDrawTextLayoutSetColor(uiDrawTextLayout *layout, int startChar, int endChar, double r, double g, double b, double a);

 void uiDrawText(uiDrawContext *c, double x, double y, uiDrawTextLayout *layout);





 typedef unsigned int uiModifiers; enum {
	uiModifierCtrl = 1,
	uiModifierAlt = 2,
	uiModifierShift = 4,
	uiModifierSuper = 8,
};

// TODO document drag captures
struct uiAreaMouseEvent {
	// TODO document what these mean for scrolling areas
	double X;
	double Y;

	// TODO see draw above
	double AreaWidth;
	double AreaHeight;

	int Down;
	int Up;

	int Count;

	uiModifiers Modifiers;

	uint64_t Held1To64;
};

 typedef unsigned int uiExtKey; enum {
	uiExtKeyEscape = 1,
	uiExtKeyInsert,			// equivalent to "Help" on Apple keyboards
	uiExtKeyDelete,
	uiExtKeyHome,
	uiExtKeyEnd,
	uiExtKeyPageUp,
	uiExtKeyPageDown,
	uiExtKeyUp,
	uiExtKeyDown,
	uiExtKeyLeft,
	uiExtKeyRight,
	uiExtKeyF1,			// F1..F12 are guaranteed to be consecutive
	uiExtKeyF2,
	uiExtKeyF3,
	uiExtKeyF4,
	uiExtKeyF5,
	uiExtKeyF6,
	uiExtKeyF7,
	uiExtKeyF8,
	uiExtKeyF9,
	uiExtKeyF10,
	uiExtKeyF11,
	uiExtKeyF12,
	uiExtKeyN0,			// numpad keys; independent of Num Lock state
	uiExtKeyN1,			// N0..N9 are guaranteed to be consecutive
	uiExtKeyN2,
	uiExtKeyN3,
	uiExtKeyN4,
	uiExtKeyN5,
	uiExtKeyN6,
	uiExtKeyN7,
	uiExtKeyN8,
	uiExtKeyN9,
	uiExtKeyNDot,
	uiExtKeyNEnter,
	uiExtKeyNAdd,
	uiExtKeyNSubtract,
	uiExtKeyNMultiply,
	uiExtKeyNDivide,
};

struct uiAreaKeyEvent {
	char Key;
	uiExtKey ExtKey;
	uiModifiers Modifier;

	uiModifiers Modifiers;

	int Up;
};

typedef struct uiFontButton uiFontButton;
//TEST DOTDOTDOT
#define uiFontButton ...
// TODO document this returns a new font
 uiDrawTextFont *uiFontButtonFont(uiFontButton *b);
// TOOD SetFont, mechanics
 void uiFontButtonOnChanged(uiFontButton *b, void (*f)(uiFontButton *, void *), void *data);
 uiFontButton *uiNewFontButton(void);

typedef struct uiColorButton uiColorButton;
//TEST DOTDOTDOT
#define uiColorButton ...
 void uiColorButtonColor(uiColorButton *b, double *r, double *g, double *bl, double *a);
 void uiColorButtonSetColor(uiColorButton *b, double r, double g, double bl, double a);
 void uiColorButtonOnChanged(uiColorButton *b, void (*f)(uiColorButton *, void *), void *data);
 uiColorButton *uiNewColorButton(void);

typedef struct uiForm uiForm;
//TEST DOTDOTDOT
#define uiForm ...
 void uiFormAppend(uiForm *f, const char *label, uiControl *c, int stretchy);
 void uiFormDelete(uiForm *f, int index);
 int uiFormPadded(uiForm *f);
 void uiFormSetPadded(uiForm *f, int padded);
 uiForm *uiNewForm(void);



 typedef unsigned int uiAlign; enum {
	uiAlignFill,
	uiAlignStart,
	uiAlignCenter,
	uiAlignEnd,
};

  typedef unsigned int uiAt; enum {
	uiAtLeading,
	uiAtTop,
	uiAtTrailing,
	uiAtBottom,
};

typedef struct uiGrid uiGrid;
//TEST DOTDOTDOT
#define uiGrid ...
 void uiGridAppend(uiGrid *g, uiControl *c, int left, int top, int xspan, int yspan, int hexpand, uiAlign halign, int vexpand, uiAlign valign);
 void uiGridInsertAt(uiGrid *g, uiControl *c, uiControl *existing, uiAt at, int xspan, int yspan, int hexpand, uiAlign halign, int vexpand, uiAlign valign);
 int uiGridPadded(uiGrid *g);
 void uiGridSetPadded(uiGrid *g, int padded);
 uiGrid *uiNewGrid(void);
''')

current = os.path.dirname(os.path.realpath(__file__))
if platform.system() == 'Linux':
    library = os.path.join(current, 'libui.so')
elif platform.system() == 'Darwin':
    library = os.path.join(current, 'libui.dylib')
elif platform.system() == 'Windows':
    library = os.path.join(current, 'libui.dll')
else:
    raise RuntimeError('Unsupported platform')
lib = ffi.dlopen(library)
callbacks = []


def uiInitOptions(*args):
    return ffi.new("uiInitOptions *", args)


def uiControl(*args):
    return ffi.new("uiControl *", args)


def uiWindow(*args):
    return ffi.new("uiWindow *", args)


def uiButton(*args):
    return ffi.new("uiButton *", args)


def uiBox(*args):
    return ffi.new("uiBox *", args)


def uiCheckbox(*args):
    return ffi.new("uiCheckbox *", args)


def uiEntry(*args):
    return ffi.new("uiEntry *", args)


def uiLabel(*args):
    return ffi.new("uiLabel *", args)


def uiTab(*args):
    return ffi.new("uiTab *", args)


def uiGroup(*args):
    return ffi.new("uiGroup *", args)


def uiSpinbox(*args):
    return ffi.new("uiSpinbox *", args)


def uiSlider(*args):
    return ffi.new("uiSlider *", args)


def uiProgressBar(*args):
    return ffi.new("uiProgressBar *", args)


def uiSeparator(*args):
    return ffi.new("uiSeparator *", args)


def uiCombobox(*args):
    return ffi.new("uiCombobox *", args)


def uiEditableCombobox(*args):
    return ffi.new("uiEditableCombobox *", args)


def uiRadioButtons(*args):
    return ffi.new("uiRadioButtons *", args)


def uiDateTimePicker(*args):
    return ffi.new("uiDateTimePicker *", args)


def uiMultilineEntry(*args):
    return ffi.new("uiMultilineEntry *", args)


def uiMenuItem(*args):
    return ffi.new("uiMenuItem *", args)


def uiMenu(*args):
    return ffi.new("uiMenu *", args)


def uiArea(*args):
    return ffi.new("uiArea *", args)


def uiAreaHandler(*args):
    return ffi.new("uiAreaHandler *", args)


def uiAreaDrawParams(*args):
    return ffi.new("uiAreaDrawParams *", args)


def uiAreaMouseEvent(*args):
    return ffi.new("uiAreaMouseEvent *", args)


def uiAreaKeyEvent(*args):
    return ffi.new("uiAreaKeyEvent *", args)


def uiDrawContext(*args):
    return ffi.new("uiDrawContext *", args)


def uiDrawPath(*args):
    return ffi.new("uiDrawPath *", args)


def uiDrawBrush(*args):
    return ffi.new("uiDrawBrush *", args)


def uiDrawStrokeParams(*args):
    return ffi.new("uiDrawStrokeParams *", args)


def uiDrawMatrix(*args):
    return ffi.new("uiDrawMatrix *", args)


def uiDrawBrushGradientStop(*args):
    return ffi.new("uiDrawBrushGradientStop *", args)


def uiDrawFontFamilies(*args):
    return ffi.new("uiDrawFontFamilies *", args)


def uiDrawTextLayout(*args):
    return ffi.new("uiDrawTextLayout *", args)


def uiDrawTextFont(*args):
    return ffi.new("uiDrawTextFont *", args)


def uiDrawTextFontDescriptor(*args):
    return ffi.new("uiDrawTextFontDescriptor *", args)


def uiDrawTextFontMetrics(*args):
    return ffi.new("uiDrawTextFontMetrics *", args)


def uiFontButton(*args):
    return ffi.new("uiFontButton *", args)


def uiColorButton(*args):
    return ffi.new("uiColorButton *", args)


def uiForm(*args):
    return ffi.new("uiForm *", args)


def uiGrid(*args):
    return ffi.new("uiGrid *", args)


def uiInit(options: uiInitOptions):
    return lib.uiInit(options)


def uiUninit():
    return lib.uiUninit()


def uiFreeInitError(err: str):
    err = err.encode()

    return lib.uiFreeInitError(err)


def uiMain():
    return lib.uiMain()


def uiMainSteps():
    return lib.uiMainSteps()


def uiMainStep(wait: int):
    return lib.uiMainStep(wait)


def uiQuit():
    return lib.uiQuit()


def uiQueueMain(callback: ffi.NULL, data: ffi.NULL):
    ffi_callback = ffi.callback("void *data);", callback)
    callbacks.append(ffi_callback)  # make sure our ffi callback will be alive

    return lib.uiQueueMain(ffi_callback, ffi.NULL)


def uiOnShouldQuit(callback: ffi.NULL, data: ffi.NULL):
    ffi_callback = ffi.callback("void *data);", callback)
    callbacks.append(ffi_callback)  # make sure our ffi callback will be alive

    return lib.uiOnShouldQuit(ffi_callback, ffi.NULL)


def uiFreeText(text: str):
    text = text.encode()

    return lib.uiFreeText(text)


def Destroy(uiControl: uiControl):
    return lib.Destroy(uiControl)


def Handle(uiControl: uiControl):
    return lib.Handle(uiControl)


def Parent(uiControl: uiControl):
    return lib.Parent(uiControl)


def SetParent(uiControl: uiControl, uiControl1: uiControl):
    return lib.SetParent(uiControl, uiControl1)


def Toplevel(uiControl: uiControl):
    return lib.Toplevel(uiControl)


def Visible(uiControl: uiControl):
    return lib.Visible(uiControl)


def Show(uiControl: uiControl):
    return lib.Show(uiControl)


def Hide(uiControl: uiControl):
    return lib.Hide(uiControl)


def Enabled(uiControl: uiControl):
    return lib.Enabled(uiControl)


def Enable(uiControl: uiControl):
    return lib.Enable(uiControl)


def Disable(uiControl: uiControl):
    return lib.Disable(uiControl)


def uiControlDestroy(uiControl: uiControl):
    return lib.uiControlDestroy(uiControl)


def uiControlHandle(uiControl: uiControl):
    return lib.uiControlHandle(uiControl)


def uiControlParent(uiControl: uiControl):
    return lib.uiControlParent(uiControl)


def uiControlSetParent(uiControl: uiControl, uiControl1: uiControl):
    return lib.uiControlSetParent(uiControl, uiControl1)


def uiControlToplevel(uiControl: uiControl):
    return lib.uiControlToplevel(uiControl)


def uiControlVisible(uiControl: uiControl):
    return lib.uiControlVisible(uiControl)


def uiControlShow(uiControl: uiControl):
    return lib.uiControlShow(uiControl)


def uiControlHide(uiControl: uiControl):
    return lib.uiControlHide(uiControl)


def uiControlEnabled(uiControl: uiControl):
    return lib.uiControlEnabled(uiControl)


def uiControlEnable(uiControl: uiControl):
    return lib.uiControlEnable(uiControl)


def uiControlDisable(uiControl: uiControl):
    return lib.uiControlDisable(uiControl)


def uiFreeControl(uiControl: uiControl):
    return lib.uiFreeControl(uiControl)


def uiControlVerifySetParent(uiControl: uiControl, uiControl1: uiControl):
    return lib.uiControlVerifySetParent(uiControl, uiControl1)


def uiControlEnabledToUser(uiControl: uiControl):
    return lib.uiControlEnabledToUser(uiControl)


def uiUserBugCannotSetParentOnToplevel(type: str):
    type = type.encode()

    return lib.uiUserBugCannotSetParentOnToplevel(type)


def uiWindowTitle(w: uiWindow):
    return ffi.string(lib.uiWindowTitle(w)).decode('utf-8')


def uiWindowSetTitle(w: uiWindow, title: str):
    title = title.encode()

    return lib.uiWindowSetTitle(w, title)


def uiWindowContentSize(w: uiWindow, width: int, height: int):
    return lib.uiWindowContentSize(w, width, height)


def uiWindowSetContentSize(w: uiWindow, width: int, height: int):
    return lib.uiWindowSetContentSize(w, width, height)


def uiWindowFullscreen(w: uiWindow):
    return lib.uiWindowFullscreen(w)


def uiWindowSetFullscreen(w: uiWindow, fullscreen: int):
    return lib.uiWindowSetFullscreen(w, fullscreen)


def uiWindowOnContentSizeChanged(w: uiWindow, callback: ffi.NULL, data: ffi.NULL):
    ffi_callback = ffi.callback("void (*f)(uiWindow *, void *)", callback)
    callbacks.append(ffi_callback)  # make sure our ffi callback will be alive

    return lib.uiWindowOnContentSizeChanged(w, ffi_callback, ffi.NULL)


def uiWindowOnClosing(w: uiWindow, callback: ffi.NULL, data: ffi.NULL):
    ffi_callback = ffi.callback("int (*f)(uiWindow *w, void *data)", callback)
    callbacks.append(ffi_callback)  # make sure our ffi callback will be alive

    return lib.uiWindowOnClosing(w, ffi_callback, ffi.NULL)


def uiWindowBorderless(w: uiWindow):
    return lib.uiWindowBorderless(w)


def uiWindowSetBorderless(w: uiWindow, borderless: int):
    return lib.uiWindowSetBorderless(w, borderless)


def uiWindowSetChild(w: uiWindow, child: uiControl):
    return lib.uiWindowSetChild(w, child)


def uiWindowMargined(w: uiWindow):
    return lib.uiWindowMargined(w)


def uiWindowSetMargined(w: uiWindow, margined: int):
    return lib.uiWindowSetMargined(w, margined)


def uiNewWindow(title: str, width: int, height: int, hasMenubar: int):
    title = title.encode()

    return lib.uiNewWindow(title, width, height, hasMenubar)


def uiButtonText(b: uiButton):
    return ffi.string(lib.uiButtonText(b)).decode('utf-8')


def uiButtonSetText(b: uiButton, text: str):
    text = text.encode()

    return lib.uiButtonSetText(b, text)


def uiButtonOnClicked(b: uiButton, callback: ffi.NULL, data: ffi.NULL):
    ffi_callback = ffi.callback("void (*f)(uiButton *b, void *data)", callback)
    callbacks.append(ffi_callback)  # make sure our ffi callback will be alive

    return lib.uiButtonOnClicked(b, ffi_callback, ffi.NULL)


def uiNewButton(text: str):
    text = text.encode()

    return lib.uiNewButton(text)


def uiBoxAppend(b: uiBox, child: uiControl, stretchy: int):
    return lib.uiBoxAppend(b, child, stretchy)


def uiBoxDelete(b: uiBox, index: int):
    return lib.uiBoxDelete(b, index)


def uiBoxPadded(b: uiBox):
    return lib.uiBoxPadded(b)


def uiBoxSetPadded(b: uiBox, padded: int):
    return lib.uiBoxSetPadded(b, padded)


def uiNewHorizontalBox():
    return lib.uiNewHorizontalBox()


def uiNewVerticalBox():
    return lib.uiNewVerticalBox()


def uiCheckboxText(c: uiCheckbox):
    return ffi.string(lib.uiCheckboxText(c)).decode('utf-8')


def uiCheckboxSetText(c: uiCheckbox, text: str):
    text = text.encode()

    return lib.uiCheckboxSetText(c, text)


def uiCheckboxOnToggled(c: uiCheckbox, callback: ffi.NULL, data: ffi.NULL):
    ffi_callback = ffi.callback("void (*f)(uiCheckbox *c, void *data)", callback)
    callbacks.append(ffi_callback)  # make sure our ffi callback will be alive

    return lib.uiCheckboxOnToggled(c, ffi_callback, ffi.NULL)


def uiCheckboxChecked(c: uiCheckbox):
    return lib.uiCheckboxChecked(c)


def uiCheckboxSetChecked(c: uiCheckbox, checked: int):
    return lib.uiCheckboxSetChecked(c, checked)


def uiNewCheckbox(text: str):
    text = text.encode()

    return lib.uiNewCheckbox(text)


def uiEntryText(e: uiEntry):
    return ffi.string(lib.uiEntryText(e)).decode('utf-8')


def uiEntrySetText(e: uiEntry, text: str):
    text = text.encode()

    return lib.uiEntrySetText(e, text)


def uiEntryOnChanged(e: uiEntry, callback: ffi.NULL, data: ffi.NULL):
    ffi_callback = ffi.callback("void (*f)(uiEntry *e, void *data)", callback)
    callbacks.append(ffi_callback)  # make sure our ffi callback will be alive

    return lib.uiEntryOnChanged(e, ffi_callback, ffi.NULL)


def uiEntryReadOnly(e: uiEntry):
    return lib.uiEntryReadOnly(e)


def uiEntrySetReadOnly(e: uiEntry, readonly: int):
    return lib.uiEntrySetReadOnly(e, readonly)


def uiNewEntry():
    return lib.uiNewEntry()


def uiNewPasswordEntry():
    return lib.uiNewPasswordEntry()


def uiNewSearchEntry():
    return lib.uiNewSearchEntry()


def uiLabelText(l: uiLabel):
    return ffi.string(lib.uiLabelText(l)).decode('utf-8')


def uiLabelSetText(l: uiLabel, text: str):
    text = text.encode()

    return lib.uiLabelSetText(l, text)


def uiNewLabel(text: str):
    text = text.encode()

    return lib.uiNewLabel(text)


def uiTabAppend(t: uiTab, name: str, c: uiControl):
    name = name.encode()

    return lib.uiTabAppend(t, name, c)


def uiTabInsertAt(t: uiTab, name: str, before: int, c: uiControl):
    name = name.encode()

    return lib.uiTabInsertAt(t, name, before, c)


def uiTabDelete(t: uiTab, index: int):
    return lib.uiTabDelete(t, index)


def uiTabNumPages(t: uiTab):
    return lib.uiTabNumPages(t)


def uiTabMargined(t: uiTab, page: int):
    return lib.uiTabMargined(t, page)


def uiTabSetMargined(t: uiTab, page: int, margined: int):
    return lib.uiTabSetMargined(t, page, margined)


def uiNewTab():
    return lib.uiNewTab()


def uiGroupTitle(g: uiGroup):
    return ffi.string(lib.uiGroupTitle(g)).decode('utf-8')


def uiGroupSetTitle(g: uiGroup, title: str):
    title = title.encode()

    return lib.uiGroupSetTitle(g, title)


def uiGroupSetChild(g: uiGroup, c: uiControl):
    return lib.uiGroupSetChild(g, c)


def uiGroupMargined(g: uiGroup):
    return lib.uiGroupMargined(g)


def uiGroupSetMargined(g: uiGroup, margined: int):
    return lib.uiGroupSetMargined(g, margined)


def uiNewGroup(title: str):
    title = title.encode()

    return lib.uiNewGroup(title)


def uiSpinboxValue(s: uiSpinbox):
    return lib.uiSpinboxValue(s)


def uiSpinboxSetValue(s: uiSpinbox, value: int):
    return lib.uiSpinboxSetValue(s, value)


def uiSpinboxOnChanged(s: uiSpinbox, callback: ffi.NULL, data: ffi.NULL):
    ffi_callback = ffi.callback("void (*f)(uiSpinbox *s, void *data)", callback)
    callbacks.append(ffi_callback)  # make sure our ffi callback will be alive

    return lib.uiSpinboxOnChanged(s, ffi_callback, ffi.NULL)


def uiNewSpinbox(min: int, max: int):
    return lib.uiNewSpinbox(min, max)


def uiSliderValue(s: uiSlider):
    return lib.uiSliderValue(s)


def uiSliderSetValue(s: uiSlider, value: int):
    return lib.uiSliderSetValue(s, value)


def uiSliderOnChanged(s: uiSlider, callback: ffi.NULL, data: ffi.NULL):
    ffi_callback = ffi.callback("void (*f)(uiSlider *s, void *data)", callback)
    callbacks.append(ffi_callback)  # make sure our ffi callback will be alive

    return lib.uiSliderOnChanged(s, ffi_callback, ffi.NULL)


def uiNewSlider(min: int, max: int):
    return lib.uiNewSlider(min, max)


def uiProgressBarValue(p: uiProgressBar):
    return lib.uiProgressBarValue(p)


def uiProgressBarSetValue(p: uiProgressBar, n: int):
    return lib.uiProgressBarSetValue(p, n)


def uiNewProgressBar():
    return lib.uiNewProgressBar()


def uiNewHorizontalSeparator():
    return lib.uiNewHorizontalSeparator()


def uiNewVerticalSeparator():
    return lib.uiNewVerticalSeparator()


def uiComboboxAppend(c: uiCombobox, text: str):
    text = text.encode()

    return lib.uiComboboxAppend(c, text)


def uiComboboxSelected(c: uiCombobox):
    return lib.uiComboboxSelected(c)


def uiComboboxSetSelected(c: uiCombobox, n: int):
    return lib.uiComboboxSetSelected(c, n)


def uiComboboxOnSelected(c: uiCombobox, callback: ffi.NULL, data: ffi.NULL):
    ffi_callback = ffi.callback("void (*f)(uiCombobox *c, void *data)", callback)
    callbacks.append(ffi_callback)  # make sure our ffi callback will be alive

    return lib.uiComboboxOnSelected(c, ffi_callback, ffi.NULL)


def uiNewCombobox():
    return lib.uiNewCombobox()


def uiEditableComboboxAppend(c: uiEditableCombobox, text: str):
    text = text.encode()

    return lib.uiEditableComboboxAppend(c, text)


def uiEditableComboboxText(c: uiEditableCombobox):
    return ffi.string(lib.uiEditableComboboxText(c)).decode('utf-8')


def uiEditableComboboxSetText(c: uiEditableCombobox, text: str):
    text = text.encode()

    return lib.uiEditableComboboxSetText(c, text)


def uiEditableComboboxOnChanged(c: uiEditableCombobox, callback: ffi.NULL, data: ffi.NULL):
    ffi_callback = ffi.callback("void (*f)(uiEditableCombobox *c, void *data)", callback)
    callbacks.append(ffi_callback)  # make sure our ffi callback will be alive

    return lib.uiEditableComboboxOnChanged(c, ffi_callback, ffi.NULL)


def uiNewEditableCombobox():
    return lib.uiNewEditableCombobox()


def uiRadioButtonsAppend(r: uiRadioButtons, text: str):
    text = text.encode()

    return lib.uiRadioButtonsAppend(r, text)


def uiRadioButtonsSelected(r: uiRadioButtons):
    return lib.uiRadioButtonsSelected(r)


def uiRadioButtonsSetSelected(r: uiRadioButtons, n: int):
    return lib.uiRadioButtonsSetSelected(r, n)


def uiRadioButtonsOnSelected(r: uiRadioButtons, callback: ffi.NULL, data: ffi.NULL):
    ffi_callback = ffi.callback("void (*f)(uiRadioButtons *, void *)", callback)
    callbacks.append(ffi_callback)  # make sure our ffi callback will be alive

    return lib.uiRadioButtonsOnSelected(r, ffi_callback, ffi.NULL)


def uiNewRadioButtons():
    return lib.uiNewRadioButtons()


def uiNewDateTimePicker():
    return lib.uiNewDateTimePicker()


def uiNewDatePicker():
    return lib.uiNewDatePicker()


def uiNewTimePicker():
    return lib.uiNewTimePicker()


def uiMultilineEntryText(e: uiMultilineEntry):
    return ffi.string(lib.uiMultilineEntryText(e)).decode('utf-8')


def uiMultilineEntrySetText(e: uiMultilineEntry, text: str):
    text = text.encode()

    return lib.uiMultilineEntrySetText(e, text)


def uiMultilineEntryAppend(e: uiMultilineEntry, text: str):
    text = text.encode()

    return lib.uiMultilineEntryAppend(e, text)


def uiMultilineEntryOnChanged(e: uiMultilineEntry, callback: ffi.NULL, data: ffi.NULL):
    ffi_callback = ffi.callback("void (*f)(uiMultilineEntry *e, void *data)", callback)
    callbacks.append(ffi_callback)  # make sure our ffi callback will be alive

    return lib.uiMultilineEntryOnChanged(e, ffi_callback, ffi.NULL)


def uiMultilineEntryReadOnly(e: uiMultilineEntry):
    return lib.uiMultilineEntryReadOnly(e)


def uiMultilineEntrySetReadOnly(e: uiMultilineEntry, readonly: int):
    return lib.uiMultilineEntrySetReadOnly(e, readonly)


def uiNewMultilineEntry():
    return lib.uiNewMultilineEntry()


def uiNewNonWrappingMultilineEntry():
    return lib.uiNewNonWrappingMultilineEntry()


def uiMenuItemEnable(m: uiMenuItem):
    return lib.uiMenuItemEnable(m)


def uiMenuItemDisable(m: uiMenuItem):
    return lib.uiMenuItemDisable(m)


def uiMenuItemOnClicked(m: uiMenuItem, callback: ffi.NULL, data: ffi.NULL):
    ffi_callback = ffi.callback("void (*f)(uiMenuItem *sender, uiWindow *window, void *data)", callback)
    callbacks.append(ffi_callback)  # make sure our ffi callback will be alive

    return lib.uiMenuItemOnClicked(m, ffi_callback, ffi.NULL)


def uiMenuItemChecked(m: uiMenuItem):
    return lib.uiMenuItemChecked(m)


def uiMenuItemSetChecked(m: uiMenuItem, checked: int):
    return lib.uiMenuItemSetChecked(m, checked)


def uiMenuAppendItem(m: uiMenu, name: str):
    name = name.encode()

    return lib.uiMenuAppendItem(m, name)


def uiMenuAppendCheckItem(m: uiMenu, name: str):
    name = name.encode()

    return lib.uiMenuAppendCheckItem(m, name)


def uiMenuAppendQuitItem(m: uiMenu):
    return lib.uiMenuAppendQuitItem(m)


def uiMenuAppendPreferencesItem(m: uiMenu):
    return lib.uiMenuAppendPreferencesItem(m)


def uiMenuAppendAboutItem(m: uiMenu):
    return lib.uiMenuAppendAboutItem(m)


def uiMenuAppendSeparator(m: uiMenu):
    return lib.uiMenuAppendSeparator(m)


def uiNewMenu(name: str):
    name = name.encode()

    return lib.uiNewMenu(name)


def uiOpenFile(parent: uiWindow):
    return ffi.string(lib.uiOpenFile(parent)).decode('utf-8')


def uiSaveFile(parent: uiWindow):
    return ffi.string(lib.uiSaveFile(parent)).decode('utf-8')


def uiMsgBox(parent: uiWindow, title: str, description: str):
    title = title.encode()
    description = description.encode()

    return lib.uiMsgBox(parent, title, description)


def uiMsgBoxError(parent: uiWindow, title: str, description: str):
    title = title.encode()
    description = description.encode()

    return lib.uiMsgBoxError(parent, title, description)


def Draw(uiAreaHandler: uiAreaHandler, uiArea: uiArea, uiAreaDrawParams: uiAreaDrawParams):
    return lib.Draw(uiAreaHandler, uiArea, uiAreaDrawParams)


def MouseEvent(uiAreaHandler: uiAreaHandler, uiArea: uiArea, uiAreaMouseEvent: uiAreaMouseEvent):
    return lib.MouseEvent(uiAreaHandler, uiArea, uiAreaMouseEvent)


def MouseCrossed(uiAreaHandler: uiAreaHandler, uiArea: uiArea, left: int):
    return lib.MouseCrossed(uiAreaHandler, uiArea, left)


def DragBroken(uiAreaHandler: uiAreaHandler, uiArea: uiArea):
    return lib.DragBroken(uiAreaHandler, uiArea)


def KeyEvent(uiAreaHandler: uiAreaHandler, uiArea: uiArea, uiAreaKeyEvent: uiAreaKeyEvent):
    return lib.KeyEvent(uiAreaHandler, uiArea, uiAreaKeyEvent)


def uiAreaSetSize(a: uiArea, width: int, height: int):
    return lib.uiAreaSetSize(a, width, height)


def uiAreaQueueRedrawAll(a: uiArea):
    return lib.uiAreaQueueRedrawAll(a)


def uiAreaScrollTo(a: uiArea, x: float, y: float, width: float, height: float):
    return lib.uiAreaScrollTo(a, x, y, width, height)


def uiAreaBeginUserWindowMove(a: uiArea):
    return lib.uiAreaBeginUserWindowMove(a)


def uiAreaBeginUserWindowResize(a: uiArea, edge):
    return lib.uiAreaBeginUserWindowResize(a, edge)


def uiNewArea(ah: uiAreaHandler):
    return lib.uiNewArea(ah)


def uiNewScrollingArea(ah: uiAreaHandler, width: int, height: int):
    return lib.uiNewScrollingArea(ah, width, height)


def uiDrawNewPath(fillMode):
    return lib.uiDrawNewPath(fillMode)


def uiDrawFreePath(p: uiDrawPath):
    return lib.uiDrawFreePath(p)


def uiDrawPathNewFigure(p: uiDrawPath, x: float, y: float):
    return lib.uiDrawPathNewFigure(p, x, y)


def uiDrawPathNewFigureWithArc(p: uiDrawPath, xCenter: float, yCenter: float, radius: float, startAngle: float,
                               sweep: float, negative: int):
    return lib.uiDrawPathNewFigureWithArc(p, xCenter, yCenter, radius, startAngle, sweep, negative)


def uiDrawPathLineTo(p: uiDrawPath, x: float, y: float):
    return lib.uiDrawPathLineTo(p, x, y)


def uiDrawPathArcTo(p: uiDrawPath, xCenter: float, yCenter: float, radius: float, startAngle: float, sweep: float,
                    negative: int):
    return lib.uiDrawPathArcTo(p, xCenter, yCenter, radius, startAngle, sweep, negative)


def uiDrawPathBezierTo(p: uiDrawPath, c1x: float, c1y: float, c2x: float, c2y: float, endX: float, endY: float):
    return lib.uiDrawPathBezierTo(p, c1x, c1y, c2x, c2y, endX, endY)


def uiDrawPathCloseFigure(p: uiDrawPath):
    return lib.uiDrawPathCloseFigure(p)


def uiDrawPathAddRectangle(p: uiDrawPath, x: float, y: float, width: float, height: float):
    return lib.uiDrawPathAddRectangle(p, x, y, width, height)


def uiDrawPathEnd(p: uiDrawPath):
    return lib.uiDrawPathEnd(p)


def uiDrawStroke(c: uiDrawContext, path: uiDrawPath, b: uiDrawBrush, p: uiDrawStrokeParams):
    return lib.uiDrawStroke(c, path, b, p)


def uiDrawFill(c: uiDrawContext, path: uiDrawPath, b: uiDrawBrush):
    return lib.uiDrawFill(c, path, b)


def uiDrawMatrixSetIdentity(m: uiDrawMatrix):
    return lib.uiDrawMatrixSetIdentity(m)


def uiDrawMatrixTranslate(m: uiDrawMatrix, x: float, y: float):
    return lib.uiDrawMatrixTranslate(m, x, y)


def uiDrawMatrixScale(m: uiDrawMatrix, xCenter: float, yCenter: float, x: float, y: float):
    return lib.uiDrawMatrixScale(m, xCenter, yCenter, x, y)


def uiDrawMatrixRotate(m: uiDrawMatrix, x: float, y: float, amount: float):
    return lib.uiDrawMatrixRotate(m, x, y, amount)


def uiDrawMatrixSkew(m: uiDrawMatrix, x: float, y: float, xamount: float, yamount: float):
    return lib.uiDrawMatrixSkew(m, x, y, xamount, yamount)


def uiDrawMatrixMultiply(dest: uiDrawMatrix, src: uiDrawMatrix):
    return lib.uiDrawMatrixMultiply(dest, src)


def uiDrawMatrixInvertible(m: uiDrawMatrix):
    return lib.uiDrawMatrixInvertible(m)


def uiDrawMatrixInvert(m: uiDrawMatrix):
    return lib.uiDrawMatrixInvert(m)


def uiDrawMatrixTransformPoint(m: uiDrawMatrix, x: float, y: float):
    return lib.uiDrawMatrixTransformPoint(m, x, y)


def uiDrawMatrixTransformSize(m: uiDrawMatrix, x: float, y: float):
    return lib.uiDrawMatrixTransformSize(m, x, y)


def uiDrawTransform(c: uiDrawContext, m: uiDrawMatrix):
    return lib.uiDrawTransform(c, m)


def uiDrawClip(c: uiDrawContext, path: uiDrawPath):
    return lib.uiDrawClip(c, path)


def uiDrawSave(c: uiDrawContext):
    return lib.uiDrawSave(c)


def uiDrawRestore(c: uiDrawContext):
    return lib.uiDrawRestore(c)


def uiDrawListFontFamilies():
    return lib.uiDrawListFontFamilies()


def uiDrawFontFamiliesNumFamilies(ff: uiDrawFontFamilies):
    return lib.uiDrawFontFamiliesNumFamilies(ff)


def uiDrawFontFamiliesFamily(ff: uiDrawFontFamilies, n: int):
    return ffi.string(lib.uiDrawFontFamiliesFamily(ff, n)).decode('utf-8')


def uiDrawFreeFontFamilies(ff: uiDrawFontFamilies):
    return lib.uiDrawFreeFontFamilies(ff)


def uiDrawLoadClosestFont(desc: uiDrawTextFontDescriptor):
    return lib.uiDrawLoadClosestFont(desc)


def uiDrawFreeTextFont(font: uiDrawTextFont):
    return lib.uiDrawFreeTextFont(font)


def uiDrawTextFontHandle(font: uiDrawTextFont):
    return lib.uiDrawTextFontHandle(font)


def uiDrawTextFontDescribe(font: uiDrawTextFont, desc: uiDrawTextFontDescriptor):
    return lib.uiDrawTextFontDescribe(font, desc)


def uiDrawTextFontGetMetrics(font: uiDrawTextFont, metrics: uiDrawTextFontMetrics):
    return lib.uiDrawTextFontGetMetrics(font, metrics)


def uiDrawNewTextLayout(text: str, defaultFont: uiDrawTextFont, width: float):
    text = text.encode()

    return lib.uiDrawNewTextLayout(text, defaultFont, width)


def uiDrawFreeTextLayout(layout: uiDrawTextLayout):
    return lib.uiDrawFreeTextLayout(layout)


def uiDrawTextLayoutSetWidth(layout: uiDrawTextLayout, width: float):
    return lib.uiDrawTextLayoutSetWidth(layout, width)


def uiDrawTextLayoutExtents(layout: uiDrawTextLayout, width: float, height: float):
    return lib.uiDrawTextLayoutExtents(layout, width, height)


def uiDrawTextLayoutSetColor(layout: uiDrawTextLayout, startChar: int, endChar: int, r: float, g: float, b: float,
                             a: float):
    return lib.uiDrawTextLayoutSetColor(layout, startChar, endChar, r, g, b, a)


def uiDrawText(c: uiDrawContext, x: float, y: float, layout: uiDrawTextLayout):
    return lib.uiDrawText(c, x, y, layout)


def uiFontButtonFont(b: uiFontButton):
    return lib.uiFontButtonFont(b)


def uiFontButtonOnChanged(b: uiFontButton, callback: ffi.NULL, data: ffi.NULL):
    ffi_callback = ffi.callback("void (*f)(uiFontButton *, void *)", callback)
    callbacks.append(ffi_callback)  # make sure our ffi callback will be alive

    return lib.uiFontButtonOnChanged(b, ffi_callback, ffi.NULL)


def uiNewFontButton():
    return lib.uiNewFontButton()


def uiColorButtonColor(b: uiColorButton, r: float, g: float, bl: float, a: float):
    return lib.uiColorButtonColor(b, r, g, bl, a)


def uiColorButtonSetColor(b: uiColorButton, r: float, g: float, bl: float, a: float):
    return lib.uiColorButtonSetColor(b, r, g, bl, a)


def uiColorButtonOnChanged(b: uiColorButton, callback: ffi.NULL, data: ffi.NULL):
    ffi_callback = ffi.callback("void (*f)(uiColorButton *, void *)", callback)
    callbacks.append(ffi_callback)  # make sure our ffi callback will be alive

    return lib.uiColorButtonOnChanged(b, ffi_callback, ffi.NULL)


def uiNewColorButton():
    return lib.uiNewColorButton()


def uiFormAppend(f: uiForm, label: str, c: uiControl, stretchy: int):
    label = label.encode()

    return lib.uiFormAppend(f, label, c, stretchy)


def uiFormDelete(f: uiForm, index: int):
    return lib.uiFormDelete(f, index)


def uiFormPadded(f: uiForm):
    return lib.uiFormPadded(f)


def uiFormSetPadded(f: uiForm, padded: int):
    return lib.uiFormSetPadded(f, padded)


def uiNewForm():
    return lib.uiNewForm()


def uiGridAppend(g: uiGrid, c: uiControl, left: int, top: int, xspan: int, yspan: int, hexpand: int, halign,
                 vexpand: int, valign):
    return lib.uiGridAppend(g, c, left, top, xspan, yspan, hexpand, halign, vexpand, valign)


def uiGridInsertAt(g: uiGrid, c: uiControl, existing: uiControl, at, xspan: int, yspan: int, hexpand: int, halign,
                   vexpand: int, valign):
    return lib.uiGridInsertAt(g, c, existing, at, xspan, yspan, hexpand, halign, vexpand, valign)


def uiGridPadded(g: uiGrid):
    return lib.uiGridPadded(g)


def uiGridSetPadded(g: uiGrid, padded: int):
    return lib.uiGridSetPadded(g, padded)


def uiNewGrid():
    return lib.uiNewGrid()
